import { _isNumberValue } from '@angular/cdk/coercion';
const MAX_SAFE_INTEGER = 9007199254740991;
function sortingDataAccessor(data, sortHeaderId) {
  const value = data[sortHeaderId];
  if (_isNumberValue(value)) {
    const numberValue = Number(value);
    // Numbers beyond `MAX_SAFE_INTEGER` can't be compared reliably so we
    // leave them as strings. For more info: https://goo.gl/y5vbSg
    return numberValue < MAX_SAFE_INTEGER ? numberValue : value;
  }
  return value;
}
/**
 * Gets a sorted copy of the data array based on the state of the Sort.
 * @param data The array of data that should be sorted.
 * @param sort The connected MatSort that holds the current sort state.
 */
export function sortData(data, sort) {
  const active = sort.active;
  const direction = sort.direction;
  if (!active || direction === '') {
    return data;
  }
  return data.sort((a, b) => {
    const valueA = sortingDataAccessor(a, active);
    const valueB = sortingDataAccessor(b, active);
    // If both valueA and valueB exist (truthy), then compare the two. Otherwise, check if
    // one value exists while the other doesn't. In this case, existing value should come last.
    // This avoids inconsistent results when comparing values to undefined/null.
    // If neither value exists, return 0 (equal).
    let comparatorResult = 0;
    if (valueA != null && valueB != null) {
      // Check if one value is greater than the other; if equal, comparatorResult should remain 0.
      if (typeof valueA === 'string' || typeof valueB === 'string') {
        // if either values are a string, then force both to be strings before localCompare
        comparatorResult = valueA.toString().localeCompare(valueB.toString());
      } else {
        if (valueA > valueB) {
          comparatorResult = 1;
        } else if (valueA < valueB) {
          comparatorResult = -1;
        }
      }
    } else if (valueA != null) {
      comparatorResult = 1;
    } else if (valueB != null) {
      comparatorResult = -1;
    }
    return comparatorResult * (direction === 'asc' ? 1 : -1);
  });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29ydC51dGlscy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3RyYWl0cy9zcmMvc29ydC9zb3J0LnV0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUd2RCxNQUFNLGdCQUFnQixHQUFHLGdCQUFnQixDQUFDO0FBQzFDLFNBQVMsbUJBQW1CLENBQzFCLElBQU8sRUFDUCxZQUFvQjtJQUVwQixNQUFNLEtBQUssR0FBSSxJQUErQixDQUFDLFlBQVksQ0FBQyxDQUFDO0lBRTdELElBQUksY0FBYyxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQ3pCLE1BQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUVsQyxxRUFBcUU7UUFDckUsOERBQThEO1FBQzlELE9BQU8sV0FBVyxHQUFHLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztLQUM3RDtJQUVELE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsUUFBUSxDQUFJLElBQVMsRUFBRSxJQUFhO0lBQ2xELE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDM0IsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztJQUNqQyxJQUFJLENBQUMsTUFBTSxJQUFJLFNBQVMsS0FBSyxFQUFFLEVBQUU7UUFDL0IsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUVELE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUN4QixNQUFNLE1BQU0sR0FBRyxtQkFBbUIsQ0FBQyxDQUFDLEVBQUUsTUFBZ0IsQ0FBQyxDQUFDO1FBQ3hELE1BQU0sTUFBTSxHQUFHLG1CQUFtQixDQUFDLENBQUMsRUFBRSxNQUFnQixDQUFDLENBQUM7UUFFeEQsc0ZBQXNGO1FBQ3RGLDJGQUEyRjtRQUMzRiw0RUFBNEU7UUFDNUUsNkNBQTZDO1FBQzdDLElBQUksZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDO1FBQ3pCLElBQUksTUFBTSxJQUFJLElBQUksSUFBSSxNQUFNLElBQUksSUFBSSxFQUFFO1lBQ3BDLDRGQUE0RjtZQUU1RixJQUFJLE9BQU8sTUFBTSxLQUFLLFFBQVEsSUFBSSxPQUFPLE1BQU0sS0FBSyxRQUFRLEVBQUU7Z0JBQzVELG1GQUFtRjtnQkFDbkYsZ0JBQWdCLEdBQUcsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQzthQUN2RTtpQkFBTTtnQkFDTCxJQUFJLE1BQU0sR0FBRyxNQUFNLEVBQUU7b0JBQ25CLGdCQUFnQixHQUFHLENBQUMsQ0FBQztpQkFDdEI7cUJBQU0sSUFBSSxNQUFNLEdBQUcsTUFBTSxFQUFFO29CQUMxQixnQkFBZ0IsR0FBRyxDQUFDLENBQUMsQ0FBQztpQkFDdkI7YUFDRjtTQUNGO2FBQU0sSUFBSSxNQUFNLElBQUksSUFBSSxFQUFFO1lBQ3pCLGdCQUFnQixHQUFHLENBQUMsQ0FBQztTQUN0QjthQUFNLElBQUksTUFBTSxJQUFJLElBQUksRUFBRTtZQUN6QixnQkFBZ0IsR0FBRyxDQUFDLENBQUMsQ0FBQztTQUN2QjtRQUVELE9BQU8sZ0JBQWdCLEdBQUcsQ0FBQyxTQUFTLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDM0QsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX2lzTnVtYmVyVmFsdWUgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHsgU29ydCB9IGZyb20gJy4vc29ydC5tb2RlbCc7XG5cbmNvbnN0IE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuZnVuY3Rpb24gc29ydGluZ0RhdGFBY2Nlc3NvcjxUPihcbiAgZGF0YTogVCxcbiAgc29ydEhlYWRlcklkOiBzdHJpbmcsXG4pOiBzdHJpbmcgfCBudW1iZXIge1xuICBjb25zdCB2YWx1ZSA9IChkYXRhIGFzIHsgW2tleTogc3RyaW5nXTogYW55IH0pW3NvcnRIZWFkZXJJZF07XG5cbiAgaWYgKF9pc051bWJlclZhbHVlKHZhbHVlKSkge1xuICAgIGNvbnN0IG51bWJlclZhbHVlID0gTnVtYmVyKHZhbHVlKTtcblxuICAgIC8vIE51bWJlcnMgYmV5b25kIGBNQVhfU0FGRV9JTlRFR0VSYCBjYW4ndCBiZSBjb21wYXJlZCByZWxpYWJseSBzbyB3ZVxuICAgIC8vIGxlYXZlIHRoZW0gYXMgc3RyaW5ncy4gRm9yIG1vcmUgaW5mbzogaHR0cHM6Ly9nb28uZ2wveTV2YlNnXG4gICAgcmV0dXJuIG51bWJlclZhbHVlIDwgTUFYX1NBRkVfSU5URUdFUiA/IG51bWJlclZhbHVlIDogdmFsdWU7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogR2V0cyBhIHNvcnRlZCBjb3B5IG9mIHRoZSBkYXRhIGFycmF5IGJhc2VkIG9uIHRoZSBzdGF0ZSBvZiB0aGUgU29ydC5cbiAqIEBwYXJhbSBkYXRhIFRoZSBhcnJheSBvZiBkYXRhIHRoYXQgc2hvdWxkIGJlIHNvcnRlZC5cbiAqIEBwYXJhbSBzb3J0IFRoZSBjb25uZWN0ZWQgTWF0U29ydCB0aGF0IGhvbGRzIHRoZSBjdXJyZW50IHNvcnQgc3RhdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzb3J0RGF0YTxUPihkYXRhOiBUW10sIHNvcnQ6IFNvcnQ8VD4pOiBUW10ge1xuICBjb25zdCBhY3RpdmUgPSBzb3J0LmFjdGl2ZTtcbiAgY29uc3QgZGlyZWN0aW9uID0gc29ydC5kaXJlY3Rpb247XG4gIGlmICghYWN0aXZlIHx8IGRpcmVjdGlvbiA9PT0gJycpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHJldHVybiBkYXRhLnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCB2YWx1ZUEgPSBzb3J0aW5nRGF0YUFjY2Vzc29yKGEsIGFjdGl2ZSBhcyBzdHJpbmcpO1xuICAgIGNvbnN0IHZhbHVlQiA9IHNvcnRpbmdEYXRhQWNjZXNzb3IoYiwgYWN0aXZlIGFzIHN0cmluZyk7XG5cbiAgICAvLyBJZiBib3RoIHZhbHVlQSBhbmQgdmFsdWVCIGV4aXN0ICh0cnV0aHkpLCB0aGVuIGNvbXBhcmUgdGhlIHR3by4gT3RoZXJ3aXNlLCBjaGVjayBpZlxuICAgIC8vIG9uZSB2YWx1ZSBleGlzdHMgd2hpbGUgdGhlIG90aGVyIGRvZXNuJ3QuIEluIHRoaXMgY2FzZSwgZXhpc3RpbmcgdmFsdWUgc2hvdWxkIGNvbWUgbGFzdC5cbiAgICAvLyBUaGlzIGF2b2lkcyBpbmNvbnNpc3RlbnQgcmVzdWx0cyB3aGVuIGNvbXBhcmluZyB2YWx1ZXMgdG8gdW5kZWZpbmVkL251bGwuXG4gICAgLy8gSWYgbmVpdGhlciB2YWx1ZSBleGlzdHMsIHJldHVybiAwIChlcXVhbCkuXG4gICAgbGV0IGNvbXBhcmF0b3JSZXN1bHQgPSAwO1xuICAgIGlmICh2YWx1ZUEgIT0gbnVsbCAmJiB2YWx1ZUIgIT0gbnVsbCkge1xuICAgICAgLy8gQ2hlY2sgaWYgb25lIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgb3RoZXI7IGlmIGVxdWFsLCBjb21wYXJhdG9yUmVzdWx0IHNob3VsZCByZW1haW4gMC5cblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZUEgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZUIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIGlmIGVpdGhlciB2YWx1ZXMgYXJlIGEgc3RyaW5nLCB0aGVuIGZvcmNlIGJvdGggdG8gYmUgc3RyaW5ncyBiZWZvcmUgbG9jYWxDb21wYXJlXG4gICAgICAgIGNvbXBhcmF0b3JSZXN1bHQgPSB2YWx1ZUEudG9TdHJpbmcoKS5sb2NhbGVDb21wYXJlKHZhbHVlQi50b1N0cmluZygpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2YWx1ZUEgPiB2YWx1ZUIpIHtcbiAgICAgICAgICBjb21wYXJhdG9yUmVzdWx0ID0gMTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZUEgPCB2YWx1ZUIpIHtcbiAgICAgICAgICBjb21wYXJhdG9yUmVzdWx0ID0gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbHVlQSAhPSBudWxsKSB7XG4gICAgICBjb21wYXJhdG9yUmVzdWx0ID0gMTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlQiAhPSBudWxsKSB7XG4gICAgICBjb21wYXJhdG9yUmVzdWx0ID0gLTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBhcmF0b3JSZXN1bHQgKiAoZGlyZWN0aW9uID09PSAnYXNjJyA/IDEgOiAtMSk7XG4gIH0pO1xufVxuIl19
